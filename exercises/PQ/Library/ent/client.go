// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"

	"excercise-library/ent/migrate"

	"excercise-library/ent/book"
	"excercise-library/ent/magazine"
	"excercise-library/ent/material"
	"excercise-library/ent/newspaper"
	"excercise-library/ent/section"

	"github.com/facebook/ent/dialect"
	"github.com/facebook/ent/dialect/sql"
	"github.com/facebook/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Book is the client for interacting with the Book builders.
	Book *BookClient
	// Magazine is the client for interacting with the Magazine builders.
	Magazine *MagazineClient
	// Material is the client for interacting with the Material builders.
	Material *MaterialClient
	// Newspaper is the client for interacting with the Newspaper builders.
	Newspaper *NewspaperClient
	// Section is the client for interacting with the Section builders.
	Section *SectionClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Book = NewBookClient(c.config)
	c.Magazine = NewMagazineClient(c.config)
	c.Material = NewMaterialClient(c.config)
	c.Newspaper = NewNewspaperClient(c.config)
	c.Section = NewSectionClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: tx, log: c.log, debug: c.debug, hooks: c.hooks}
	return &Tx{
		ctx:       ctx,
		config:    cfg,
		Book:      NewBookClient(cfg),
		Magazine:  NewMagazineClient(cfg),
		Material:  NewMaterialClient(cfg),
		Newspaper: NewNewspaperClient(cfg),
		Section:   NewSectionClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(*sql.Driver).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: &txDriver{tx: tx, drv: c.driver}, log: c.log, debug: c.debug, hooks: c.hooks}
	return &Tx{
		config:    cfg,
		Book:      NewBookClient(cfg),
		Magazine:  NewMagazineClient(cfg),
		Material:  NewMaterialClient(cfg),
		Newspaper: NewNewspaperClient(cfg),
		Section:   NewSectionClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Book.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := config{driver: dialect.Debug(c.driver, c.log), log: c.log, debug: true, hooks: c.hooks}
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Book.Use(hooks...)
	c.Magazine.Use(hooks...)
	c.Material.Use(hooks...)
	c.Newspaper.Use(hooks...)
	c.Section.Use(hooks...)
}

// BookClient is a client for the Book schema.
type BookClient struct {
	config
}

// NewBookClient returns a client for the Book from the given config.
func NewBookClient(c config) *BookClient {
	return &BookClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `book.Hooks(f(g(h())))`.
func (c *BookClient) Use(hooks ...Hook) {
	c.hooks.Book = append(c.hooks.Book, hooks...)
}

// Create returns a create builder for Book.
func (c *BookClient) Create() *BookCreate {
	mutation := newBookMutation(c.config, OpCreate)
	return &BookCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Book entities.
func (c *BookClient) CreateBulk(builders ...*BookCreate) *BookCreateBulk {
	return &BookCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Book.
func (c *BookClient) Update() *BookUpdate {
	mutation := newBookMutation(c.config, OpUpdate)
	return &BookUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BookClient) UpdateOne(b *Book) *BookUpdateOne {
	mutation := newBookMutation(c.config, OpUpdateOne, withBook(b))
	return &BookUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BookClient) UpdateOneID(id int) *BookUpdateOne {
	mutation := newBookMutation(c.config, OpUpdateOne, withBookID(id))
	return &BookUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Book.
func (c *BookClient) Delete() *BookDelete {
	mutation := newBookMutation(c.config, OpDelete)
	return &BookDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *BookClient) DeleteOne(b *Book) *BookDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *BookClient) DeleteOneID(id int) *BookDeleteOne {
	builder := c.Delete().Where(book.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BookDeleteOne{builder}
}

// Query returns a query builder for Book.
func (c *BookClient) Query() *BookQuery {
	return &BookQuery{config: c.config}
}

// Get returns a Book entity by its id.
func (c *BookClient) Get(ctx context.Context, id int) (*Book, error) {
	return c.Query().Where(book.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BookClient) GetX(ctx context.Context, id int) *Book {
	b, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return b
}

// QueryRelatedMaterial queries the relatedMaterial edge of a Book.
func (c *BookClient) QueryRelatedMaterial(b *Book) *MaterialQuery {
	query := &MaterialQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(book.Table, book.FieldID, id),
			sqlgraph.To(material.Table, material.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, book.RelatedMaterialTable, book.RelatedMaterialColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BookClient) Hooks() []Hook {
	return c.hooks.Book
}

// MagazineClient is a client for the Magazine schema.
type MagazineClient struct {
	config
}

// NewMagazineClient returns a client for the Magazine from the given config.
func NewMagazineClient(c config) *MagazineClient {
	return &MagazineClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `magazine.Hooks(f(g(h())))`.
func (c *MagazineClient) Use(hooks ...Hook) {
	c.hooks.Magazine = append(c.hooks.Magazine, hooks...)
}

// Create returns a create builder for Magazine.
func (c *MagazineClient) Create() *MagazineCreate {
	mutation := newMagazineMutation(c.config, OpCreate)
	return &MagazineCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Magazine entities.
func (c *MagazineClient) CreateBulk(builders ...*MagazineCreate) *MagazineCreateBulk {
	return &MagazineCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Magazine.
func (c *MagazineClient) Update() *MagazineUpdate {
	mutation := newMagazineMutation(c.config, OpUpdate)
	return &MagazineUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MagazineClient) UpdateOne(m *Magazine) *MagazineUpdateOne {
	mutation := newMagazineMutation(c.config, OpUpdateOne, withMagazine(m))
	return &MagazineUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MagazineClient) UpdateOneID(id int) *MagazineUpdateOne {
	mutation := newMagazineMutation(c.config, OpUpdateOne, withMagazineID(id))
	return &MagazineUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Magazine.
func (c *MagazineClient) Delete() *MagazineDelete {
	mutation := newMagazineMutation(c.config, OpDelete)
	return &MagazineDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *MagazineClient) DeleteOne(m *Magazine) *MagazineDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *MagazineClient) DeleteOneID(id int) *MagazineDeleteOne {
	builder := c.Delete().Where(magazine.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MagazineDeleteOne{builder}
}

// Query returns a query builder for Magazine.
func (c *MagazineClient) Query() *MagazineQuery {
	return &MagazineQuery{config: c.config}
}

// Get returns a Magazine entity by its id.
func (c *MagazineClient) Get(ctx context.Context, id int) (*Magazine, error) {
	return c.Query().Where(magazine.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MagazineClient) GetX(ctx context.Context, id int) *Magazine {
	m, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return m
}

// QueryRelatedMaterial queries the relatedMaterial edge of a Magazine.
func (c *MagazineClient) QueryRelatedMaterial(m *Magazine) *MaterialQuery {
	query := &MaterialQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(magazine.Table, magazine.FieldID, id),
			sqlgraph.To(material.Table, material.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, magazine.RelatedMaterialTable, magazine.RelatedMaterialColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySection queries the Section edge of a Magazine.
func (c *MagazineClient) QuerySection(m *Magazine) *SectionQuery {
	query := &SectionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(magazine.Table, magazine.FieldID, id),
			sqlgraph.To(section.Table, section.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, magazine.SectionTable, magazine.SectionColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MagazineClient) Hooks() []Hook {
	return c.hooks.Magazine
}

// MaterialClient is a client for the Material schema.
type MaterialClient struct {
	config
}

// NewMaterialClient returns a client for the Material from the given config.
func NewMaterialClient(c config) *MaterialClient {
	return &MaterialClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `material.Hooks(f(g(h())))`.
func (c *MaterialClient) Use(hooks ...Hook) {
	c.hooks.Material = append(c.hooks.Material, hooks...)
}

// Create returns a create builder for Material.
func (c *MaterialClient) Create() *MaterialCreate {
	mutation := newMaterialMutation(c.config, OpCreate)
	return &MaterialCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Material entities.
func (c *MaterialClient) CreateBulk(builders ...*MaterialCreate) *MaterialCreateBulk {
	return &MaterialCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Material.
func (c *MaterialClient) Update() *MaterialUpdate {
	mutation := newMaterialMutation(c.config, OpUpdate)
	return &MaterialUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MaterialClient) UpdateOne(m *Material) *MaterialUpdateOne {
	mutation := newMaterialMutation(c.config, OpUpdateOne, withMaterial(m))
	return &MaterialUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MaterialClient) UpdateOneID(id int) *MaterialUpdateOne {
	mutation := newMaterialMutation(c.config, OpUpdateOne, withMaterialID(id))
	return &MaterialUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Material.
func (c *MaterialClient) Delete() *MaterialDelete {
	mutation := newMaterialMutation(c.config, OpDelete)
	return &MaterialDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *MaterialClient) DeleteOne(m *Material) *MaterialDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *MaterialClient) DeleteOneID(id int) *MaterialDeleteOne {
	builder := c.Delete().Where(material.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MaterialDeleteOne{builder}
}

// Query returns a query builder for Material.
func (c *MaterialClient) Query() *MaterialQuery {
	return &MaterialQuery{config: c.config}
}

// Get returns a Material entity by its id.
func (c *MaterialClient) Get(ctx context.Context, id int) (*Material, error) {
	return c.Query().Where(material.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MaterialClient) GetX(ctx context.Context, id int) *Material {
	m, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return m
}

// QueryBook queries the Book edge of a Material.
func (c *MaterialClient) QueryBook(m *Material) *BookQuery {
	query := &BookQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(material.Table, material.FieldID, id),
			sqlgraph.To(book.Table, book.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, material.BookTable, material.BookColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNewspaper queries the Newspaper edge of a Material.
func (c *MaterialClient) QueryNewspaper(m *Material) *NewspaperQuery {
	query := &NewspaperQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(material.Table, material.FieldID, id),
			sqlgraph.To(newspaper.Table, newspaper.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, material.NewspaperTable, material.NewspaperColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMagazine queries the Magazine edge of a Material.
func (c *MaterialClient) QueryMagazine(m *Material) *MagazineQuery {
	query := &MagazineQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(material.Table, material.FieldID, id),
			sqlgraph.To(magazine.Table, magazine.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, material.MagazineTable, material.MagazineColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MaterialClient) Hooks() []Hook {
	return c.hooks.Material
}

// NewspaperClient is a client for the Newspaper schema.
type NewspaperClient struct {
	config
}

// NewNewspaperClient returns a client for the Newspaper from the given config.
func NewNewspaperClient(c config) *NewspaperClient {
	return &NewspaperClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `newspaper.Hooks(f(g(h())))`.
func (c *NewspaperClient) Use(hooks ...Hook) {
	c.hooks.Newspaper = append(c.hooks.Newspaper, hooks...)
}

// Create returns a create builder for Newspaper.
func (c *NewspaperClient) Create() *NewspaperCreate {
	mutation := newNewspaperMutation(c.config, OpCreate)
	return &NewspaperCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Newspaper entities.
func (c *NewspaperClient) CreateBulk(builders ...*NewspaperCreate) *NewspaperCreateBulk {
	return &NewspaperCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Newspaper.
func (c *NewspaperClient) Update() *NewspaperUpdate {
	mutation := newNewspaperMutation(c.config, OpUpdate)
	return &NewspaperUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NewspaperClient) UpdateOne(n *Newspaper) *NewspaperUpdateOne {
	mutation := newNewspaperMutation(c.config, OpUpdateOne, withNewspaper(n))
	return &NewspaperUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NewspaperClient) UpdateOneID(id int) *NewspaperUpdateOne {
	mutation := newNewspaperMutation(c.config, OpUpdateOne, withNewspaperID(id))
	return &NewspaperUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Newspaper.
func (c *NewspaperClient) Delete() *NewspaperDelete {
	mutation := newNewspaperMutation(c.config, OpDelete)
	return &NewspaperDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *NewspaperClient) DeleteOne(n *Newspaper) *NewspaperDeleteOne {
	return c.DeleteOneID(n.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *NewspaperClient) DeleteOneID(id int) *NewspaperDeleteOne {
	builder := c.Delete().Where(newspaper.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NewspaperDeleteOne{builder}
}

// Query returns a query builder for Newspaper.
func (c *NewspaperClient) Query() *NewspaperQuery {
	return &NewspaperQuery{config: c.config}
}

// Get returns a Newspaper entity by its id.
func (c *NewspaperClient) Get(ctx context.Context, id int) (*Newspaper, error) {
	return c.Query().Where(newspaper.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NewspaperClient) GetX(ctx context.Context, id int) *Newspaper {
	n, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return n
}

// QueryRelatedMaterial queries the relatedMaterial edge of a Newspaper.
func (c *NewspaperClient) QueryRelatedMaterial(n *Newspaper) *MaterialQuery {
	query := &MaterialQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(newspaper.Table, newspaper.FieldID, id),
			sqlgraph.To(material.Table, material.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, newspaper.RelatedMaterialTable, newspaper.RelatedMaterialColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NewspaperClient) Hooks() []Hook {
	return c.hooks.Newspaper
}

// SectionClient is a client for the Section schema.
type SectionClient struct {
	config
}

// NewSectionClient returns a client for the Section from the given config.
func NewSectionClient(c config) *SectionClient {
	return &SectionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `section.Hooks(f(g(h())))`.
func (c *SectionClient) Use(hooks ...Hook) {
	c.hooks.Section = append(c.hooks.Section, hooks...)
}

// Create returns a create builder for Section.
func (c *SectionClient) Create() *SectionCreate {
	mutation := newSectionMutation(c.config, OpCreate)
	return &SectionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Section entities.
func (c *SectionClient) CreateBulk(builders ...*SectionCreate) *SectionCreateBulk {
	return &SectionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Section.
func (c *SectionClient) Update() *SectionUpdate {
	mutation := newSectionMutation(c.config, OpUpdate)
	return &SectionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SectionClient) UpdateOne(s *Section) *SectionUpdateOne {
	mutation := newSectionMutation(c.config, OpUpdateOne, withSection(s))
	return &SectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SectionClient) UpdateOneID(id int) *SectionUpdateOne {
	mutation := newSectionMutation(c.config, OpUpdateOne, withSectionID(id))
	return &SectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Section.
func (c *SectionClient) Delete() *SectionDelete {
	mutation := newSectionMutation(c.config, OpDelete)
	return &SectionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *SectionClient) DeleteOne(s *Section) *SectionDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *SectionClient) DeleteOneID(id int) *SectionDeleteOne {
	builder := c.Delete().Where(section.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SectionDeleteOne{builder}
}

// Query returns a query builder for Section.
func (c *SectionClient) Query() *SectionQuery {
	return &SectionQuery{config: c.config}
}

// Get returns a Section entity by its id.
func (c *SectionClient) Get(ctx context.Context, id int) (*Section, error) {
	return c.Query().Where(section.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SectionClient) GetX(ctx context.Context, id int) *Section {
	s, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return s
}

// Hooks returns the client hooks.
func (c *SectionClient) Hooks() []Hook {
	return c.hooks.Section
}
